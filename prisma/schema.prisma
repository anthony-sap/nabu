// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  USER
}

enum StatusEnum {
  ENABLE
  DISABLE
}

enum ThoughtSource {
  WEB
  TELEGRAM
  WHATSAPP
  TEAMS
  EMAIL
  VOICE
  OTHER
}

enum ThoughtState {
  NEW
  ENRICHED
  GROUPED
  PROMOTED
  ARCHIVED
}

enum NoteVisibility {
  PRIVATE
  SHARED
  PUBLIC
}

enum NoteLinkRelation {
  RELATED
  EXPANDS
  SUPPORTS
  CONTRADICTS
  FOLLOWS_UP
}

enum TagType {
  TOPIC
  PROJECT
  CLIENT
  OTHER
}

enum ShareEntityType {
  NOTE
  TAG
  FOLDER
}

enum SharePermission {
  VIEW
  COMMENT
  EDIT
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum TagSource {
  USER_ADDED
  AI_SUGGESTED
}

model Tenant {
  id              String            @id @default(cuid())
  status          StatusEnum        @default(ENABLE)
  name            String            @db.VarChar(50)
  createdAt       DateTime          @default(now())
  createdBy       String?
  updatedAt       DateTime          @default(now()) @updatedAt
  updatedBy       String?
  deletedAt       DateTime?
  AuditLog        AuditLog[]
  Account         Account[]
  User            User[]
  Folder          Folder[]
  Tag             Tag[]
  Note            Note[]
  Thought         Thought[]
  NoteLink        NoteLink[]
  Attachment      Attachment[]
  Share           Share[]
  ImageAttachment ImageAttachment[]
  NoteChunk       NoteChunk[]
  ThoughtChunk    ThoughtChunk[]
  EmbeddingJob    EmbeddingJob[]
}

model AuditLog {
  id               String    @id @default(cuid())
  entityType       String    @db.VarChar(50)
  entityId         String
  action           String    @db.VarChar(50)
  actionReason     String?
  eventStatus      String?
  eventDescription String?
  oldData          Json?
  newData          Json?
  createdAt        DateTime  @default(now())
  createdBy        String?
  tenantId         String?
  Tenant           Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  deletedAt        DateTime?
}

model Account {
  id                String    @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?   @db.Text
  access_token      String?   @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?   @db.Text
  session_state     String?
  tenantId          String?
  Tenant            Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt         DateTime  @default(now())
  createdBy         String?
  updatedAt         DateTime  @default(now()) @updatedAt
  updatedBy         String?
  deletedAt         DateTime?
  User              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id                     String     @id @default(cuid())
  status                 StatusEnum @default(ENABLE)
  firstName              String?
  lastName               String?
  email                  String?    @unique
  emailVerified          DateTime?
  image                  String?
  roles                  UserRole[] @default([USER])
  tenantId               String?
  Tenant                 Tenant?    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt              DateTime   @default(now())
  createdBy              String?
  updatedAt              DateTime   @default(now()) @updatedAt
  updatedBy              String?
  deletedAt              DateTime?
  accounts               Account[]
  sessions               Session[]
  stripeCustomerId       String?    @unique @map(name: "stripe_customer_id")
  stripeSubscriptionId   String?    @unique @map(name: "stripe_subscription_id")
  stripePriceId          String?    @map(name: "stripe_price_id")
  stripeCurrentPeriodEnd DateTime?  @map(name: "stripe_current_period_end")
  thoughts               Thought[]
  notes                  Note[]
  folders                Folder[]
  tags                   Tag[]
  shares                 Share[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Folder {
  id          String     @id @default(cuid())
  tenantId    String?
  tenant      Tenant?    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId      String
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  color       String?
  description String?
  parentId    String?
  parent      Folder?    @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children    Folder[]   @relation("FolderHierarchy")
  order       Int?
  status      StatusEnum @default(ENABLE)
  createdAt   DateTime   @default(now())
  createdBy   String?
  updatedAt   DateTime   @default(now()) @updatedAt
  updatedBy   String?
  deletedAt   DateTime?
  notes       Note[]

  @@index([tenantId, userId])
}

model Tag {
  id        String     @id @default(cuid())
  tenantId  String?
  tenant    Tenant?    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  color     String?
  type      TagType?
  status    StatusEnum @default(ENABLE)
  createdAt DateTime   @default(now())
  createdBy String?
  updatedAt DateTime   @default(now()) @updatedAt
  updatedBy String?
  deletedAt DateTime?
  noteTags  NoteTag[]

  @@unique([tenantId, userId, name])
  @@index([tenantId, userId])
}

model Note {
  id                   String            @id @default(cuid())
  tenantId             String?
  tenant               Tenant?           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId               String
  user                 User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  folderId             String?
  folder               Folder?           @relation(fields: [folderId], references: [id], onDelete: SetNull)
  title                String
  content              String            @db.Text
  contentState         String?           @db.Text // Lexical editor serialized state (JSON)
  sourceThoughts       String[]
  summary              String?           @db.Text
  visibility           NoteVisibility    @default(PRIVATE)
  status               StatusEnum        @default(ENABLE)
  tagSuggestionStatus  String?           // "pending", "completed", null
  lastTagSuggestionAt  DateTime?         // When last suggestion was made (cooldown)
  lastTagModifiedAt    DateTime?         // When user last manually modified tags
  pendingJobId         String?           // Current pending job ID
  createdAt            DateTime          @default(now())
  createdBy            String?
  updatedAt            DateTime          @default(now()) @updatedAt
  updatedBy            String?
  deletedAt            DateTime?
  noteTags             NoteTag[]
  attachments          Attachment[]
  images               ImageAttachment[]
  outgoingLinks        NoteLink[]        @relation("NoteOutgoing")
  incomingLinks        NoteLink[]        @relation("NoteIncoming")
  thoughts             Thought[]
  chunks               NoteChunk[]       // Chunked content for embeddings

  @@index([tenantId, userId])
  @@index([folderId])
}

model Thought {
  id                   String        @id @default(cuid())
  tenantId             String?
  tenant               Tenant?       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId               String
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  noteId               String?
  note                 Note?         @relation(fields: [noteId], references: [id], onDelete: SetNull)
  content              String        @db.Text
  source               ThoughtSource
  state                ThoughtState  @default(NEW)
  suggestedTags        String[]
  meta                 Json?
  tagSuggestionStatus  String?       // "pending", "completed", null
  lastTagSuggestionAt  DateTime?     // When last suggestion was made (cooldown)
  lastTagModifiedAt    DateTime?     // When user last manually modified tags
  pendingJobId         String?       // Current pending job ID
  createdAt            DateTime      @default(now())
  createdBy            String?
  updatedAt            DateTime      @default(now()) @updatedAt
  updatedBy            String?
  deletedAt            DateTime?
  attachments          Attachment[]
  chunks               ThoughtChunk[] // Chunked content for embeddings

  @@index([tenantId, userId])
  @@index([noteId])
}

model NoteTag {
  noteId     String
  tagId      String
  tenantId  String?
  confidence Float?
  source     TagSource @default(USER_ADDED)
  createdAt            DateTime      @default(now())
  createdBy            String?
  updatedAt            DateTime      @default(now()) @updatedAt
  updatedBy            String?
  deletedAt            DateTime?

  note Note @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([noteId, tagId])
}

model NoteLink {
  id         String           @id @default(cuid())
  tenantId   String?
  tenant     Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  fromNoteId String
  toNoteId   String
  relation   NoteLinkRelation
  createdAt            DateTime      @default(now())
  createdBy            String?
  updatedAt            DateTime      @default(now()) @updatedAt
  updatedBy            String?
  deletedAt            DateTime?

  from Note @relation("NoteOutgoing", fields: [fromNoteId], references: [id], onDelete: Cascade)
  to   Note @relation("NoteIncoming", fields: [toNoteId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([fromNoteId])
  @@index([toNoteId])
}

model TagSuggestionJob {
  id            String    @id @default(cuid())
  tenantId      String?
  userId        String
  entityType    String    // "NOTE" or "THOUGHT"
  entityId      String
  content       String    @db.Text
  status        JobStatus @default(PENDING)
  
  // Results
  suggestedTags String[]  // Tag names suggested by AI
  confidence    Float?    // Overall confidence score
  
  // Metadata
  attempts      Int       @default(0)
  lastAttemptAt DateTime?
  error         String?   @db.Text
  consumed      Boolean   @default(false) // Prevents reuse
  
 createdAt     DateTime  @default(now())
  createdBy     String?
  updatedAt     DateTime  @default(now()) @updatedAt
  updatedBy     String?
  deletedAt     DateTime?
  
  @@index([status, createdAt])
  @@index([entityType, entityId])
  @@index([userId])
  @@index([consumed])
}

model Attachment {
  id            String    @id @default(cuid())
  tenantId      String?
  tenant        Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  noteId        String?
  note          Note?     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  thoughtId     String?
  thought       Thought?  @relation(fields: [thoughtId], references: [id], onDelete: Cascade)
  fileName      String
  fileUrl       String
  mimeType      String
  extractedText String?   @db.Text
  embedding     Bytes?
  createdAt     DateTime  @default(now())
  createdBy     String?
  updatedAt     DateTime  @default(now()) @updatedAt
  updatedBy     String?
  deletedAt     DateTime?

  @@index([tenantId])
  @@index([noteId])
  @@index([thoughtId])
}

model Share {
  id         String          @id @default(cuid())
  tenantId   String?
  tenant     Tenant?         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  entityType ShareEntityType
  entityId   String
  userId     String
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission SharePermission
  createdAt            DateTime      @default(now())
  createdBy            String?
  updatedAt            DateTime      @default(now()) @updatedAt
  updatedBy            String?
  deletedAt            DateTime?
  revokedAt  DateTime?

  @@index([tenantId, entityType, entityId])
  @@index([userId])
}

// Image attachments for notes - stored in Supabase storage
model ImageAttachment {
  id               String    @id @default(cuid())
  noteId           String
  note             Note      @relation(fields: [noteId], references: [id], onDelete: Cascade)
  
  // File metadata
  filename         String    // Unique filename in storage (uuid-originalname)
  originalFilename String    // Original uploaded filename
  storagePath      String    // Full path in Supabase: {tenantId}/note-images/{noteId}/{filename}
  url              String?   // Public URL from Supabase (null until upload confirmed)
  
  // File properties
  fileSize         Int       // Size in bytes
  mimeType         String    // image/jpeg, image/png, etc.
  width            Int?      // Image width in pixels
  height           Int?      // Image height in pixels
  
  // Optimized versions (generated by edge function)
  thumbnailUrl     String?   // 300px width
  mediumUrl        String?   // 800px width
  
  // Multi-tenancy
  tenantId         String
  tenant           Tenant    @relation(fields: [tenantId], references: [id])
  
  // Audit timestamps
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  
  // Audit users
  createdBy        String
  updatedBy        String
  
  // Soft delete
  deletedAt        DateTime?
  deletedBy        String?
  
  @@index([noteId])
  @@index([tenantId])
  @@index([fileSize]) // For storage reporting
  @@index([createdAt]) // For reporting queries
}

// Chunked note content for embeddings
// Handles long notes by splitting into ~2000 char chunks with overlap
model NoteChunk {
  id         String                       @id @default(cuid())
  noteId     String
  note       Note                         @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tenantId   String
  tenant     Tenant                       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  chunkIndex Int                          // Order of chunk (0, 1, 2, etc.)
  content    String                       @db.Text // Chunked text content
  embedding  Unsupported("vector(512)")?  // Vector embedding (512 dimensions - OpenAI text-embedding-3-small)
  
  // Audit fields
  createdAt  DateTime                     @default(now())
  createdBy  String?
  updatedAt  DateTime                     @updatedAt
  updatedBy  String?
  deletedAt  DateTime?
  deletedBy  String?
  
  @@index([noteId])
  @@index([tenantId])
}

// Chunked thought content for embeddings
// Handles long thoughts by splitting into ~2000 char chunks with overlap
model ThoughtChunk {
  id         String                       @id @default(cuid())
  thoughtId  String
  thought    Thought                      @relation(fields: [thoughtId], references: [id], onDelete: Cascade)
  tenantId   String
  tenant     Tenant                       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  chunkIndex Int                          // Order of chunk (0, 1, 2, etc.)
  content    String                       @db.Text // Chunked text content
  embedding  Unsupported("vector(512)")?  // Vector embedding (512 dimensions - OpenAI text-embedding-3-small)
  
  // Audit fields
  createdAt  DateTime                     @default(now())
  createdBy  String?
  updatedAt  DateTime                     @updatedAt
  updatedBy  String?
  deletedAt  DateTime?
  deletedBy  String?
  
  @@index([thoughtId])
  @@index([tenantId])
}

// Job queue for generating embeddings
// Similar to TagSuggestionJob but for embeddings
model EmbeddingJob {
  id            String    @id @default(cuid())
  tenantId      String?
  tenant        Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId        String
  entityType    String    // "NOTE" or "THOUGHT"
  entityId      String    // Note or Thought ID
  chunkId       String    // NoteChunk or ThoughtChunk ID
  chunkIndex    Int       // Index of chunk being processed
  content       String    @db.Text // Text content to embed
  status        JobStatus @default(PENDING)
  
  // Metadata for retry logic
  attempts      Int       @default(0)
  lastAttemptAt DateTime?
  error         String?   @db.Text
  
  // Audit fields
  createdAt     DateTime  @default(now())
  createdBy     String?
  updatedAt     DateTime  @default(now()) @updatedAt
  updatedBy     String?
  deletedAt     DateTime?
  deletedBy     String?
  
  @@index([status, createdAt])
  @@index([entityType, entityId])
  @@index([userId])
  @@index([tenantId])
}
